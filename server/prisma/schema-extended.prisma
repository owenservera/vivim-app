// OpenScroll Extended Prisma Schema
// Combines current extraction schema with blueprint ACU/P2P features
// Database: PostgreSQL
// Runtime: Bun
//
// This schema extends the existing schema.prisma with:
// - ACU (Atomic Chat Unit) tables for knowledge graph
// - Identity management (User, Device)
// - Sharing infrastructure (Circle)
// - Vector embeddings support
// - Graph relationships (ACU Links)

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DATABASE_URL")
}

// ============================================================================
// EXISTING TABLES (Keep as-is for backward compatibility)
// ============================================================================

model Conversation {
  id          String   @id @default(uuid())
  
  // Source Information
  provider    String
  sourceUrl   String   @unique
  
  // Conversation Metadata
  title       String   @db.Text
  model       String?
  
  // Timestamps
  createdAt   DateTime @db.Timestamptz
  updatedAt   DateTime @db.Timestamptz
  capturedAt  DateTime @default(now()) @db.Timestamptz
  
  // Statistics
  messageCount      Int @default(0)
  userMessageCount  Int @default(0)
  aiMessageCount    Int @default(0)
  totalWords        Int @default(0)
  totalCharacters   Int @default(0)
  totalTokens       Int?
  totalCodeBlocks      Int @default(0)
  totalImages          Int @default(0)
  totalTables          Int @default(0)
  totalLatexBlocks     Int @default(0)
  totalMermaidDiagrams Int @default(0)
  totalToolCalls       Int @default(0)
  
  // Relationships
  messages    Message[]
  acus        AtomicChatUnit[] // NEW: Link to generated ACUs
  
  // Metadata
  metadata    Json @default("{}")
  
  // NEW: Owner tracking
  ownerId     String?
  owner       User? @relation(fields: [ownerId], references: [id])
  
  // Indexes
  @@index([provider])
  @@index([capturedAt(sort: Desc)])
  @@index([provider, capturedAt(sort: Desc)])
  @@index([sourceUrl])
  @@index([createdAt(sort: Desc)])
  @@index([ownerId])
  @@map("conversations")
}

model Message {
  id              String   @id @default(uuid())
  conversationId  String
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  // Message Core Fields
  role            String
  author          String?
  parts           Json
  
  // Timestamps
  createdAt       DateTime @db.Timestamptz
  messageIndex    Int
  
  // Status
  status          String   @default("completed")
  finishReason    String?
  tokenCount      Int?
  metadata        Json @default("{}")
  
  // NEW: Link to generated ACUs
  acus            AtomicChatUnit[]
  
  // Indexes
  @@index([conversationId, messageIndex])
  @@index([conversationId, createdAt])
  @@index([role])
  @@map("messages")
}

model CaptureAttempt {
  id          String   @id @default(uuid())
  sourceUrl   String
  provider    String?
  status      String
  errorCode   String?
  errorMessage String? @db.Text
  errorStack  String? @db.Text
  startedAt   DateTime @db.Timestamptz
  completedAt DateTime? @db.Timestamptz
  duration    Int?
  ipAddress   String?
  userAgent   String?  @db.Text
  conversationId String?
  retryCount  Int @default(0)
  retryOf     String?
  createdAt   DateTime @default(now()) @db.Timestamptz
  
  @@index([sourceUrl])
  @@index([status])
  @@index([createdAt(sort: Desc)])
  @@index([ipAddress, createdAt(sort: Desc)])
  @@index([conversationId])
  @@map("capture_attempts")
}

model ProviderStats {
  id              String   @id @default(uuid())
  provider        String   @unique
  totalCaptures      Int @default(0)
  successfulCaptures Int @default(0)
  failedCaptures     Int @default(0)
  avgDuration        Float?
  avgMessageCount    Float?
  avgTokenCount      Float?
  totalMessages      Int @default(0)
  totalCodeBlocks    Int @default(0)
  totalImages        Int @default(0)
  totalToolCalls     Int @default(0)
  lastCaptureAt   DateTime? @db.Timestamptz
  updatedAt       DateTime @updatedAt @db.Timestamptz
  
  @@map("provider_stats")
}

// ============================================================================
// NEW: IDENTITY & USER MANAGEMENT (Blueprint)
// ============================================================================

model User {
  id          String   @id @default(uuid())
  
  // Decentralized Identifier (DID)
  did         String   @unique // did:key:z6Mk...
  
  // Profile
  displayName String?
  email       String?  @unique
  avatarUrl   String?
  
  // Cryptographic keys (stored encrypted)
  publicKey   String   @db.Text // Ed25519 public key
  encryptedPrivateKey String? @db.Text // Encrypted with device key
  
  // Timestamps
  createdAt   DateTime @default(now()) @db.Timestamptz
  updatedAt   DateTime @updatedAt @db.Timestamptz
  lastSeenAt  DateTime @default(now()) @db.Timestamptz
  
  // Relationships
  devices         Device[]
  conversations   Conversation[]
  acus            AtomicChatUnit[]
  circlesOwned    Circle[] @relation("CircleOwner")
  circleMemberships CircleMember[]
  
  // Settings (JSONB)
  settings    Json @default("{}")
  
  // Indexes
  @@index([did])
  @@index([email])
  @@map("users")
}

model Device {
  id          String   @id @default(uuid())
  
  // Owner
  userId      String
  user        User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Device Info
  deviceId    String   @unique // Unique device identifier
  deviceName  String   // "iPhone 15 Pro", "Chrome on MacBook"
  deviceType  String   // "mobile", "desktop", "browser"
  platform    String   // "ios", "android", "web", "macos", "windows"
  
  // Device fingerprint (for security)
  fingerprint String?  @db.Text
  
  // Cryptographic keys
  publicKey   String   @db.Text
  
  // Status
  isActive    Boolean  @default(true)
  isTrusted   Boolean  @default(false)
  
  // Timestamps
  createdAt   DateTime @default(now()) @db.Timestamptz
  updatedAt   DateTime @updatedAt @db.Timestamptz
  lastSeenAt  DateTime @default(now()) @db.Timestamptz
  
  // Metadata
  metadata    Json @default("{}")
  
  // Indexes
  @@index([userId])
  @@index([deviceId])
  @@index([userId, isActive])
  @@map("devices")
}

// ============================================================================
// NEW: ATOMIC CHAT UNITS (ACUs) - Core Knowledge Graph
// ============================================================================

model AtomicChatUnit {
  id          String   @id // Content hash (SHA3-256)
  
  // Authorship
  authorDid   String
  author      User @relation(fields: [authorDid], references: [did])
  signature   Bytes    // Ed25519 signature
  
  // Content
  content     String   @db.Text
  language    String?  // For code snippets
  
  // Semantic Classification
  type        String   // "statement", "question", "answer", "code_snippet", etc.
  category    String   // "technical", "conceptual", "procedural", "personal"
  
  // Embeddings (for semantic search)
  embedding   Float[] // 384-dimensional vector (stored as array)
  embeddingModel String? // "phi-3-mini", "all-MiniLM-L6-v2"
  
  // Provenance (where this ACU came from)
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  messageId      String
  message        Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  messageIndex   Int
  provider       String
  model          String?
  sourceTimestamp DateTime @db.Timestamptz
  
  // Extraction metadata
  extractorVersion String?
  parserVersion    String?
  
  // Quality Metrics
  qualityOverall        Float? // 0-100 composite score
  contentRichness       Float?
  structuralIntegrity   Float?
  uniqueness            Float?
  
  // Usage Statistics
  viewCount     Int @default(0)
  shareCount    Int @default(0)
  quoteCount    Int @default(0)
  rediscoveryScore Float?
  
  // Sharing Policy
  sharingPolicy String @default("self") // "self", "circle", "network"
  sharingCircles String[] // Array of circle IDs
  canView       Boolean @default(true)
  canAnnotate   Boolean @default(false)
  canRemix      Boolean @default(false)
  canReshare    Boolean @default(false)
  expiresAt     DateTime? @db.Timestamptz
  
  // Timestamps
  createdAt     DateTime @default(now()) @db.Timestamptz
  indexedAt     DateTime @default(now()) @db.Timestamptz
  
  // Relationships
  linksFrom     AcuLink[] @relation("SourceAcu")
  linksTo       AcuLink[] @relation("TargetAcu")
  
  // Metadata
  metadata      Json @default("{}")
  
  // Indexes
  @@index([conversationId])
  @@index([messageId])
  @@index([authorDid])
  @@index([type])
  @@index([category])
  @@index([qualityOverall(sort: Desc)])
  @@index([rediscoveryScore(sort: Desc)])
  @@index([createdAt(sort: Desc)])
  @@index([sharingPolicy])
  @@map("atomic_chat_units")
}

// ============================================================================
// NEW: ACU GRAPH RELATIONSHIPS
// ============================================================================

model AcuLink {
  id          String   @id @default(uuid())
  
  // Source and Target ACUs
  sourceId    String
  source      AtomicChatUnit @relation("SourceAcu", fields: [sourceId], references: [id], onDelete: Cascade)
  
  targetId    String
  target      AtomicChatUnit @relation("TargetAcu", fields: [targetId], references: [id], onDelete: Cascade)
  
  // Relationship Type
  relation    String   // "next", "previous", "explains", "answers", "similar_to", etc.
  
  // Confidence/Weight
  weight      Float    @default(1.0) // 0.0 - 1.0
  
  // Timestamps
  createdAt   DateTime @default(now()) @db.Timestamptz
  
  // Metadata
  metadata    Json @default("{}")
  
  // Unique constraint: one relation type per source-target pair
  @@unique([sourceId, targetId, relation])
  @@index([sourceId])
  @@index([targetId])
  @@index([relation])
  @@map("acu_links")
}

// ============================================================================
// NEW: SHARING & CIRCLES (P2P Foundation)
// ============================================================================

model Circle {
  id          String   @id @default(uuid())
  
  // Owner
  ownerId     String
  owner       User @relation("CircleOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  
  // Circle Info
  name        String
  description String?  @db.Text
  
  // Visibility
  isPublic    Boolean  @default(false)
  
  // Members
  members     CircleMember[]
  
  // Timestamps
  createdAt   DateTime @default(now()) @db.Timestamptz
  updatedAt   DateTime @updatedAt @db.Timestamptz
  
  // Metadata
  metadata    Json @default("{}")
  
  // Indexes
  @@index([ownerId])
  @@index([isPublic])
  @@map("circles")
}

model CircleMember {
  id          String   @id @default(uuid())
  
  // Circle
  circleId    String
  circle      Circle @relation(fields: [circleId], references: [id], onDelete: Cascade)
  
  // Member
  userId      String
  user        User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Role
  role        String   @default("member") // "owner", "admin", "member"
  
  // Permissions
  canInvite   Boolean  @default(false)
  canShare    Boolean  @default(true)
  
  // Timestamps
  joinedAt    DateTime @default(now()) @db.Timestamptz
  
  // Unique constraint: one membership per user per circle
  @@unique([circleId, userId])
  @@index([circleId])
  @@index([userId])
  @@map("circle_members")
}

// ============================================================================
// NEW: RECIPROCITY TRACKING (P2P Network)
// ============================================================================

model Contribution {
  id          String   @id @default(uuid())
  
  // Contributor
  contributorDid String
  
  // Content shared
  acuId       String
  
  // Recipients
  recipientDids String[] // Array of DIDs who received this
  
  // Quality of contribution
  quality     Float    @default(1.0)
  
  // Timestamps
  timestamp   DateTime @default(now()) @db.Timestamptz
  
  // Metadata
  metadata    Json @default("{}")
  
  // Indexes
  @@index([contributorDid])
  @@index([acuId])
  @@index([timestamp(sort: Desc)])
  @@map("contributions")
}

model Consumption {
  id          String   @id @default(uuid())
  
  // Consumer
  consumerDid String
  
  // Content received
  acuId       String
  
  // Provider
  providerDid String
  
  // Timestamps
  timestamp   DateTime @default(now()) @db.Timestamptz
  
  // Metadata
  metadata    Json @default("{}")
  
  // Indexes
  @@index([consumerDid])
  @@index([acuId])
  @@index([providerDid])
  @@index([timestamp(sort: Desc)])
  @@map("consumptions")
}

// ============================================================================
// VIEWS & MATERIALIZED VIEWS (Optional - for performance)
// ============================================================================

// Note: Prisma doesn't support views natively, but you can create them
// manually in migrations. Here's the SQL for reference:

// CREATE VIEW v_conversations_with_acu_count AS
// SELECT 
//   c.*,
//   COUNT(a.id) as acu_count
// FROM conversations c
// LEFT JOIN atomic_chat_units a ON c.id = a."conversationId"
// GROUP BY c.id;

// CREATE VIEW v_top_acus AS
// SELECT *
// FROM atomic_chat_units
// WHERE "qualityOverall" >= 80
// ORDER BY "rediscoveryScore" DESC
// LIMIT 100;

// CREATE MATERIALIZED VIEW v_user_reciprocity_scores AS
// SELECT 
//   u.did,
//   COUNT(DISTINCT contrib.id) as contribution_count,
//   COUNT(DISTINCT consum.id) as consumption_count,
//   COALESCE(AVG(contrib.quality), 0) as avg_contribution_quality,
//   CASE 
//     WHEN COUNT(DISTINCT consum.id) = 0 THEN COUNT(DISTINCT contrib.id) * 2.0
//     ELSE (COUNT(DISTINCT contrib.id)::float / COUNT(DISTINCT consum.id)::float)
//   END as reciprocity_score
// FROM users u
// LEFT JOIN contributions contrib ON u.did = contrib."contributorDid"
// LEFT JOIN consumptions consum ON u.did = consum."consumerDid"
// GROUP BY u.did;
